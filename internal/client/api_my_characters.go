/*
Artifacts API

 Artifacts is an API-based MMO game where you can manage 5 characters to explore, fight, gather resources, craft items and much more.  Website: https://artifactsmmo.com/  Documentation: https://docs.artifactsmmo.com/  OpenAPI Spec: https://api.artifactsmmo.com/openapi.json 

API version: 1.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type MyCharactersAPI interface {

	/*
	ActionAcceptNewTaskMyNameActionTaskNewPost Action Accept New Task

	Accepting a new task.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiActionAcceptNewTaskMyNameActionTaskNewPostRequest
	*/
	ActionAcceptNewTaskMyNameActionTaskNewPost(ctx context.Context, name string) ApiActionAcceptNewTaskMyNameActionTaskNewPostRequest

	// ActionAcceptNewTaskMyNameActionTaskNewPostExecute executes the request
	//  @return TaskResponseSchema
	ActionAcceptNewTaskMyNameActionTaskNewPostExecute(r ApiActionAcceptNewTaskMyNameActionTaskNewPostRequest) (*TaskResponseSchema, *http.Response, error)

	/*
	ActionCompleteTaskMyNameActionTaskCompletePost Action Complete Task

	Complete a task.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiActionCompleteTaskMyNameActionTaskCompletePostRequest
	*/
	ActionCompleteTaskMyNameActionTaskCompletePost(ctx context.Context, name string) ApiActionCompleteTaskMyNameActionTaskCompletePostRequest

	// ActionCompleteTaskMyNameActionTaskCompletePostExecute executes the request
	//  @return TaskRewardResponseSchema
	ActionCompleteTaskMyNameActionTaskCompletePostExecute(r ApiActionCompleteTaskMyNameActionTaskCompletePostRequest) (*TaskRewardResponseSchema, *http.Response, error)

	/*
	ActionCraftingMyNameActionCraftingPost Action Crafting

	Crafting an item. The character must be on a map with a workshop.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiActionCraftingMyNameActionCraftingPostRequest
	*/
	ActionCraftingMyNameActionCraftingPost(ctx context.Context, name string) ApiActionCraftingMyNameActionCraftingPostRequest

	// ActionCraftingMyNameActionCraftingPostExecute executes the request
	//  @return SkillResponseSchema
	ActionCraftingMyNameActionCraftingPostExecute(r ApiActionCraftingMyNameActionCraftingPostRequest) (*SkillResponseSchema, *http.Response, error)

	/*
	ActionDeleteItemMyNameActionDeletePost Action Delete Item

	Delete an item from your character's inventory.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiActionDeleteItemMyNameActionDeletePostRequest
	*/
	ActionDeleteItemMyNameActionDeletePost(ctx context.Context, name string) ApiActionDeleteItemMyNameActionDeletePostRequest

	// ActionDeleteItemMyNameActionDeletePostExecute executes the request
	//  @return DeleteItemResponseSchema
	ActionDeleteItemMyNameActionDeletePostExecute(r ApiActionDeleteItemMyNameActionDeletePostRequest) (*DeleteItemResponseSchema, *http.Response, error)

	/*
	ActionDepositBankGoldMyNameActionBankDepositGoldPost Action Deposit Bank Gold

	Deposit golds in a bank on the character's map.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiActionDepositBankGoldMyNameActionBankDepositGoldPostRequest
	*/
	ActionDepositBankGoldMyNameActionBankDepositGoldPost(ctx context.Context, name string) ApiActionDepositBankGoldMyNameActionBankDepositGoldPostRequest

	// ActionDepositBankGoldMyNameActionBankDepositGoldPostExecute executes the request
	//  @return GoldResponseSchema
	ActionDepositBankGoldMyNameActionBankDepositGoldPostExecute(r ApiActionDepositBankGoldMyNameActionBankDepositGoldPostRequest) (*GoldResponseSchema, *http.Response, error)

	/*
	ActionDepositBankMyNameActionBankDepositPost Action Deposit Bank

	Deposit an item in a bank on the character's map.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiActionDepositBankMyNameActionBankDepositPostRequest
	*/
	ActionDepositBankMyNameActionBankDepositPost(ctx context.Context, name string) ApiActionDepositBankMyNameActionBankDepositPostRequest

	// ActionDepositBankMyNameActionBankDepositPostExecute executes the request
	//  @return ActionItemBankReponseSchema
	ActionDepositBankMyNameActionBankDepositPostExecute(r ApiActionDepositBankMyNameActionBankDepositPostRequest) (*ActionItemBankReponseSchema, *http.Response, error)

	/*
	ActionEquipItemMyNameActionEquipPost Action Equip Item

	Equip an item on your character.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiActionEquipItemMyNameActionEquipPostRequest
	*/
	ActionEquipItemMyNameActionEquipPost(ctx context.Context, name string) ApiActionEquipItemMyNameActionEquipPostRequest

	// ActionEquipItemMyNameActionEquipPostExecute executes the request
	//  @return EquipmentResponseSchema
	ActionEquipItemMyNameActionEquipPostExecute(r ApiActionEquipItemMyNameActionEquipPostRequest) (*EquipmentResponseSchema, *http.Response, error)

	/*
	ActionFightMyNameActionFightPost Action Fight

	Start a fight against a monster on the character's map.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiActionFightMyNameActionFightPostRequest
	*/
	ActionFightMyNameActionFightPost(ctx context.Context, name string) ApiActionFightMyNameActionFightPostRequest

	// ActionFightMyNameActionFightPostExecute executes the request
	//  @return CharacterFightResponseSchema
	ActionFightMyNameActionFightPostExecute(r ApiActionFightMyNameActionFightPostRequest) (*CharacterFightResponseSchema, *http.Response, error)

	/*
	ActionGatheringMyNameActionGatheringPost Action Gathering

	Harvest a resource on the character's map.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiActionGatheringMyNameActionGatheringPostRequest
	*/
	ActionGatheringMyNameActionGatheringPost(ctx context.Context, name string) ApiActionGatheringMyNameActionGatheringPostRequest

	// ActionGatheringMyNameActionGatheringPostExecute executes the request
	//  @return SkillResponseSchema
	ActionGatheringMyNameActionGatheringPostExecute(r ApiActionGatheringMyNameActionGatheringPostRequest) (*SkillResponseSchema, *http.Response, error)

	/*
	ActionGeBuyItemMyNameActionGeBuyPost Action Ge Buy Item

	Buy an item at the Grand Exchange on the character's map.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiActionGeBuyItemMyNameActionGeBuyPostRequest
	*/
	ActionGeBuyItemMyNameActionGeBuyPost(ctx context.Context, name string) ApiActionGeBuyItemMyNameActionGeBuyPostRequest

	// ActionGeBuyItemMyNameActionGeBuyPostExecute executes the request
	//  @return GETransactionResponseSchema
	ActionGeBuyItemMyNameActionGeBuyPostExecute(r ApiActionGeBuyItemMyNameActionGeBuyPostRequest) (*GETransactionResponseSchema, *http.Response, error)

	/*
	ActionGeSellItemMyNameActionGeSellPost Action Ge Sell Item

	Sell an item at the Grand Exchange on the character's map.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiActionGeSellItemMyNameActionGeSellPostRequest
	*/
	ActionGeSellItemMyNameActionGeSellPost(ctx context.Context, name string) ApiActionGeSellItemMyNameActionGeSellPostRequest

	// ActionGeSellItemMyNameActionGeSellPostExecute executes the request
	//  @return GETransactionResponseSchema
	ActionGeSellItemMyNameActionGeSellPostExecute(r ApiActionGeSellItemMyNameActionGeSellPostRequest) (*GETransactionResponseSchema, *http.Response, error)

	/*
	ActionMoveMyNameActionMovePost Action Move

	Moves a character on the map using the map's X and Y position.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiActionMoveMyNameActionMovePostRequest
	*/
	ActionMoveMyNameActionMovePost(ctx context.Context, name string) ApiActionMoveMyNameActionMovePostRequest

	// ActionMoveMyNameActionMovePostExecute executes the request
	//  @return CharacterMovementResponseSchema
	ActionMoveMyNameActionMovePostExecute(r ApiActionMoveMyNameActionMovePostRequest) (*CharacterMovementResponseSchema, *http.Response, error)

	/*
	ActionRecyclingMyNameActionRecyclingPost Action Recycling

	Recyling an item. The character must be on a map with a workshop (only for equipments and weapons).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiActionRecyclingMyNameActionRecyclingPostRequest
	*/
	ActionRecyclingMyNameActionRecyclingPost(ctx context.Context, name string) ApiActionRecyclingMyNameActionRecyclingPostRequest

	// ActionRecyclingMyNameActionRecyclingPostExecute executes the request
	//  @return RecylingResponseSchema
	ActionRecyclingMyNameActionRecyclingPostExecute(r ApiActionRecyclingMyNameActionRecyclingPostRequest) (*RecylingResponseSchema, *http.Response, error)

	/*
	ActionTaskExchangeMyNameActionTaskExchangePost Action Task Exchange

	Exchange 3 tasks coins for a random reward. Rewards are exclusive resources for crafting  items.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiActionTaskExchangeMyNameActionTaskExchangePostRequest
	*/
	ActionTaskExchangeMyNameActionTaskExchangePost(ctx context.Context, name string) ApiActionTaskExchangeMyNameActionTaskExchangePostRequest

	// ActionTaskExchangeMyNameActionTaskExchangePostExecute executes the request
	//  @return TaskRewardResponseSchema
	ActionTaskExchangeMyNameActionTaskExchangePostExecute(r ApiActionTaskExchangeMyNameActionTaskExchangePostRequest) (*TaskRewardResponseSchema, *http.Response, error)

	/*
	ActionUnequipItemMyNameActionUnequipPost Action Unequip Item

	Unequip an item on your character.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiActionUnequipItemMyNameActionUnequipPostRequest
	*/
	ActionUnequipItemMyNameActionUnequipPost(ctx context.Context, name string) ApiActionUnequipItemMyNameActionUnequipPostRequest

	// ActionUnequipItemMyNameActionUnequipPostExecute executes the request
	//  @return EquipmentResponseSchema
	ActionUnequipItemMyNameActionUnequipPostExecute(r ApiActionUnequipItemMyNameActionUnequipPostRequest) (*EquipmentResponseSchema, *http.Response, error)

	/*
	ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost Action Withdraw Bank Gold

	Withdraw gold from your bank.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRequest
	*/
	ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost(ctx context.Context, name string) ApiActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRequest

	// ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostExecute executes the request
	//  @return GoldResponseSchema
	ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostExecute(r ApiActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRequest) (*GoldResponseSchema, *http.Response, error)

	/*
	ActionWithdrawBankMyNameActionBankWithdrawPost Action Withdraw Bank

	Take an item from your bank and put it in the character's inventory.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiActionWithdrawBankMyNameActionBankWithdrawPostRequest
	*/
	ActionWithdrawBankMyNameActionBankWithdrawPost(ctx context.Context, name string) ApiActionWithdrawBankMyNameActionBankWithdrawPostRequest

	// ActionWithdrawBankMyNameActionBankWithdrawPostExecute executes the request
	//  @return ActionItemBankReponseSchema
	ActionWithdrawBankMyNameActionBankWithdrawPostExecute(r ApiActionWithdrawBankMyNameActionBankWithdrawPostRequest) (*ActionItemBankReponseSchema, *http.Response, error)

	/*
	GetAllCharactersLogsMyLogsGet Get All Characters Logs

	History of the last 300 actions of all your characters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAllCharactersLogsMyLogsGetRequest
	*/
	GetAllCharactersLogsMyLogsGet(ctx context.Context) ApiGetAllCharactersLogsMyLogsGetRequest

	// GetAllCharactersLogsMyLogsGetExecute executes the request
	//  @return DataPageActionSchema
	GetAllCharactersLogsMyLogsGetExecute(r ApiGetAllCharactersLogsMyLogsGetRequest) (*DataPageActionSchema, *http.Response, error)

	/*
	GetCharacterLogsMyNameLogsGet Get Character Logs

	History of your character's last 300 actions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of your character.
	@return ApiGetCharacterLogsMyNameLogsGetRequest
	*/
	GetCharacterLogsMyNameLogsGet(ctx context.Context, name string) ApiGetCharacterLogsMyNameLogsGetRequest

	// GetCharacterLogsMyNameLogsGetExecute executes the request
	//  @return DataPageActionSchema
	GetCharacterLogsMyNameLogsGetExecute(r ApiGetCharacterLogsMyNameLogsGetRequest) (*DataPageActionSchema, *http.Response, error)

	/*
	GetMyCharactersMyCharactersGet Get My Characters

	List of your characters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMyCharactersMyCharactersGetRequest
	*/
	GetMyCharactersMyCharactersGet(ctx context.Context) ApiGetMyCharactersMyCharactersGetRequest

	// GetMyCharactersMyCharactersGetExecute executes the request
	//  @return DataPageMyCharacterSchema
	GetMyCharactersMyCharactersGetExecute(r ApiGetMyCharactersMyCharactersGetRequest) (*DataPageMyCharacterSchema, *http.Response, error)
}

// MyCharactersAPIService MyCharactersAPI service
type MyCharactersAPIService service

type ApiActionAcceptNewTaskMyNameActionTaskNewPostRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
}

func (r ApiActionAcceptNewTaskMyNameActionTaskNewPostRequest) Execute() (*TaskResponseSchema, *http.Response, error) {
	return r.ApiService.ActionAcceptNewTaskMyNameActionTaskNewPostExecute(r)
}

/*
ActionAcceptNewTaskMyNameActionTaskNewPost Action Accept New Task

Accepting a new task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiActionAcceptNewTaskMyNameActionTaskNewPostRequest
*/
func (a *MyCharactersAPIService) ActionAcceptNewTaskMyNameActionTaskNewPost(ctx context.Context, name string) ApiActionAcceptNewTaskMyNameActionTaskNewPostRequest {
	return ApiActionAcceptNewTaskMyNameActionTaskNewPostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return TaskResponseSchema
func (a *MyCharactersAPIService) ActionAcceptNewTaskMyNameActionTaskNewPostExecute(r ApiActionAcceptNewTaskMyNameActionTaskNewPostRequest) (*TaskResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.ActionAcceptNewTaskMyNameActionTaskNewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/action/task/new"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionCompleteTaskMyNameActionTaskCompletePostRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
}

func (r ApiActionCompleteTaskMyNameActionTaskCompletePostRequest) Execute() (*TaskRewardResponseSchema, *http.Response, error) {
	return r.ApiService.ActionCompleteTaskMyNameActionTaskCompletePostExecute(r)
}

/*
ActionCompleteTaskMyNameActionTaskCompletePost Action Complete Task

Complete a task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiActionCompleteTaskMyNameActionTaskCompletePostRequest
*/
func (a *MyCharactersAPIService) ActionCompleteTaskMyNameActionTaskCompletePost(ctx context.Context, name string) ApiActionCompleteTaskMyNameActionTaskCompletePostRequest {
	return ApiActionCompleteTaskMyNameActionTaskCompletePostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return TaskRewardResponseSchema
func (a *MyCharactersAPIService) ActionCompleteTaskMyNameActionTaskCompletePostExecute(r ApiActionCompleteTaskMyNameActionTaskCompletePostRequest) (*TaskRewardResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskRewardResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.ActionCompleteTaskMyNameActionTaskCompletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/action/task/complete"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionCraftingMyNameActionCraftingPostRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
	craftingSchema *CraftingSchema
}

func (r ApiActionCraftingMyNameActionCraftingPostRequest) CraftingSchema(craftingSchema CraftingSchema) ApiActionCraftingMyNameActionCraftingPostRequest {
	r.craftingSchema = &craftingSchema
	return r
}

func (r ApiActionCraftingMyNameActionCraftingPostRequest) Execute() (*SkillResponseSchema, *http.Response, error) {
	return r.ApiService.ActionCraftingMyNameActionCraftingPostExecute(r)
}

/*
ActionCraftingMyNameActionCraftingPost Action Crafting

Crafting an item. The character must be on a map with a workshop.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiActionCraftingMyNameActionCraftingPostRequest
*/
func (a *MyCharactersAPIService) ActionCraftingMyNameActionCraftingPost(ctx context.Context, name string) ApiActionCraftingMyNameActionCraftingPostRequest {
	return ApiActionCraftingMyNameActionCraftingPostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return SkillResponseSchema
func (a *MyCharactersAPIService) ActionCraftingMyNameActionCraftingPostExecute(r ApiActionCraftingMyNameActionCraftingPostRequest) (*SkillResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SkillResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.ActionCraftingMyNameActionCraftingPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/action/crafting"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.craftingSchema == nil {
		return localVarReturnValue, nil, reportError("craftingSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.craftingSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionDeleteItemMyNameActionDeletePostRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
	simpleItemSchema *SimpleItemSchema
}

func (r ApiActionDeleteItemMyNameActionDeletePostRequest) SimpleItemSchema(simpleItemSchema SimpleItemSchema) ApiActionDeleteItemMyNameActionDeletePostRequest {
	r.simpleItemSchema = &simpleItemSchema
	return r
}

func (r ApiActionDeleteItemMyNameActionDeletePostRequest) Execute() (*DeleteItemResponseSchema, *http.Response, error) {
	return r.ApiService.ActionDeleteItemMyNameActionDeletePostExecute(r)
}

/*
ActionDeleteItemMyNameActionDeletePost Action Delete Item

Delete an item from your character's inventory.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiActionDeleteItemMyNameActionDeletePostRequest
*/
func (a *MyCharactersAPIService) ActionDeleteItemMyNameActionDeletePost(ctx context.Context, name string) ApiActionDeleteItemMyNameActionDeletePostRequest {
	return ApiActionDeleteItemMyNameActionDeletePostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return DeleteItemResponseSchema
func (a *MyCharactersAPIService) ActionDeleteItemMyNameActionDeletePostExecute(r ApiActionDeleteItemMyNameActionDeletePostRequest) (*DeleteItemResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteItemResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.ActionDeleteItemMyNameActionDeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/action/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.simpleItemSchema == nil {
		return localVarReturnValue, nil, reportError("simpleItemSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.simpleItemSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionDepositBankGoldMyNameActionBankDepositGoldPostRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
	depositWithdrawGoldSchema *DepositWithdrawGoldSchema
}

func (r ApiActionDepositBankGoldMyNameActionBankDepositGoldPostRequest) DepositWithdrawGoldSchema(depositWithdrawGoldSchema DepositWithdrawGoldSchema) ApiActionDepositBankGoldMyNameActionBankDepositGoldPostRequest {
	r.depositWithdrawGoldSchema = &depositWithdrawGoldSchema
	return r
}

func (r ApiActionDepositBankGoldMyNameActionBankDepositGoldPostRequest) Execute() (*GoldResponseSchema, *http.Response, error) {
	return r.ApiService.ActionDepositBankGoldMyNameActionBankDepositGoldPostExecute(r)
}

/*
ActionDepositBankGoldMyNameActionBankDepositGoldPost Action Deposit Bank Gold

Deposit golds in a bank on the character's map.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiActionDepositBankGoldMyNameActionBankDepositGoldPostRequest
*/
func (a *MyCharactersAPIService) ActionDepositBankGoldMyNameActionBankDepositGoldPost(ctx context.Context, name string) ApiActionDepositBankGoldMyNameActionBankDepositGoldPostRequest {
	return ApiActionDepositBankGoldMyNameActionBankDepositGoldPostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return GoldResponseSchema
func (a *MyCharactersAPIService) ActionDepositBankGoldMyNameActionBankDepositGoldPostExecute(r ApiActionDepositBankGoldMyNameActionBankDepositGoldPostRequest) (*GoldResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GoldResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.ActionDepositBankGoldMyNameActionBankDepositGoldPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/action/bank/deposit/gold"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.depositWithdrawGoldSchema == nil {
		return localVarReturnValue, nil, reportError("depositWithdrawGoldSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.depositWithdrawGoldSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionDepositBankMyNameActionBankDepositPostRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
	simpleItemSchema *SimpleItemSchema
}

func (r ApiActionDepositBankMyNameActionBankDepositPostRequest) SimpleItemSchema(simpleItemSchema SimpleItemSchema) ApiActionDepositBankMyNameActionBankDepositPostRequest {
	r.simpleItemSchema = &simpleItemSchema
	return r
}

func (r ApiActionDepositBankMyNameActionBankDepositPostRequest) Execute() (*ActionItemBankReponseSchema, *http.Response, error) {
	return r.ApiService.ActionDepositBankMyNameActionBankDepositPostExecute(r)
}

/*
ActionDepositBankMyNameActionBankDepositPost Action Deposit Bank

Deposit an item in a bank on the character's map.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiActionDepositBankMyNameActionBankDepositPostRequest
*/
func (a *MyCharactersAPIService) ActionDepositBankMyNameActionBankDepositPost(ctx context.Context, name string) ApiActionDepositBankMyNameActionBankDepositPostRequest {
	return ApiActionDepositBankMyNameActionBankDepositPostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ActionItemBankReponseSchema
func (a *MyCharactersAPIService) ActionDepositBankMyNameActionBankDepositPostExecute(r ApiActionDepositBankMyNameActionBankDepositPostRequest) (*ActionItemBankReponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionItemBankReponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.ActionDepositBankMyNameActionBankDepositPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/action/bank/deposit"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.simpleItemSchema == nil {
		return localVarReturnValue, nil, reportError("simpleItemSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.simpleItemSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionEquipItemMyNameActionEquipPostRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
	equipSchema *EquipSchema
}

func (r ApiActionEquipItemMyNameActionEquipPostRequest) EquipSchema(equipSchema EquipSchema) ApiActionEquipItemMyNameActionEquipPostRequest {
	r.equipSchema = &equipSchema
	return r
}

func (r ApiActionEquipItemMyNameActionEquipPostRequest) Execute() (*EquipmentResponseSchema, *http.Response, error) {
	return r.ApiService.ActionEquipItemMyNameActionEquipPostExecute(r)
}

/*
ActionEquipItemMyNameActionEquipPost Action Equip Item

Equip an item on your character.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiActionEquipItemMyNameActionEquipPostRequest
*/
func (a *MyCharactersAPIService) ActionEquipItemMyNameActionEquipPost(ctx context.Context, name string) ApiActionEquipItemMyNameActionEquipPostRequest {
	return ApiActionEquipItemMyNameActionEquipPostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return EquipmentResponseSchema
func (a *MyCharactersAPIService) ActionEquipItemMyNameActionEquipPostExecute(r ApiActionEquipItemMyNameActionEquipPostRequest) (*EquipmentResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EquipmentResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.ActionEquipItemMyNameActionEquipPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/action/equip/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.equipSchema == nil {
		return localVarReturnValue, nil, reportError("equipSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.equipSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionFightMyNameActionFightPostRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
}

func (r ApiActionFightMyNameActionFightPostRequest) Execute() (*CharacterFightResponseSchema, *http.Response, error) {
	return r.ApiService.ActionFightMyNameActionFightPostExecute(r)
}

/*
ActionFightMyNameActionFightPost Action Fight

Start a fight against a monster on the character's map.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiActionFightMyNameActionFightPostRequest
*/
func (a *MyCharactersAPIService) ActionFightMyNameActionFightPost(ctx context.Context, name string) ApiActionFightMyNameActionFightPostRequest {
	return ApiActionFightMyNameActionFightPostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return CharacterFightResponseSchema
func (a *MyCharactersAPIService) ActionFightMyNameActionFightPostExecute(r ApiActionFightMyNameActionFightPostRequest) (*CharacterFightResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CharacterFightResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.ActionFightMyNameActionFightPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/action/fight"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionGatheringMyNameActionGatheringPostRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
}

func (r ApiActionGatheringMyNameActionGatheringPostRequest) Execute() (*SkillResponseSchema, *http.Response, error) {
	return r.ApiService.ActionGatheringMyNameActionGatheringPostExecute(r)
}

/*
ActionGatheringMyNameActionGatheringPost Action Gathering

Harvest a resource on the character's map.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiActionGatheringMyNameActionGatheringPostRequest
*/
func (a *MyCharactersAPIService) ActionGatheringMyNameActionGatheringPost(ctx context.Context, name string) ApiActionGatheringMyNameActionGatheringPostRequest {
	return ApiActionGatheringMyNameActionGatheringPostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return SkillResponseSchema
func (a *MyCharactersAPIService) ActionGatheringMyNameActionGatheringPostExecute(r ApiActionGatheringMyNameActionGatheringPostRequest) (*SkillResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SkillResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.ActionGatheringMyNameActionGatheringPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/action/gathering"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionGeBuyItemMyNameActionGeBuyPostRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
	gETransactionItemSchema *GETransactionItemSchema
}

func (r ApiActionGeBuyItemMyNameActionGeBuyPostRequest) GETransactionItemSchema(gETransactionItemSchema GETransactionItemSchema) ApiActionGeBuyItemMyNameActionGeBuyPostRequest {
	r.gETransactionItemSchema = &gETransactionItemSchema
	return r
}

func (r ApiActionGeBuyItemMyNameActionGeBuyPostRequest) Execute() (*GETransactionResponseSchema, *http.Response, error) {
	return r.ApiService.ActionGeBuyItemMyNameActionGeBuyPostExecute(r)
}

/*
ActionGeBuyItemMyNameActionGeBuyPost Action Ge Buy Item

Buy an item at the Grand Exchange on the character's map.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiActionGeBuyItemMyNameActionGeBuyPostRequest
*/
func (a *MyCharactersAPIService) ActionGeBuyItemMyNameActionGeBuyPost(ctx context.Context, name string) ApiActionGeBuyItemMyNameActionGeBuyPostRequest {
	return ApiActionGeBuyItemMyNameActionGeBuyPostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return GETransactionResponseSchema
func (a *MyCharactersAPIService) ActionGeBuyItemMyNameActionGeBuyPostExecute(r ApiActionGeBuyItemMyNameActionGeBuyPostRequest) (*GETransactionResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GETransactionResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.ActionGeBuyItemMyNameActionGeBuyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/action/ge/buy"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gETransactionItemSchema == nil {
		return localVarReturnValue, nil, reportError("gETransactionItemSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gETransactionItemSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionGeSellItemMyNameActionGeSellPostRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
	gETransactionItemSchema *GETransactionItemSchema
}

func (r ApiActionGeSellItemMyNameActionGeSellPostRequest) GETransactionItemSchema(gETransactionItemSchema GETransactionItemSchema) ApiActionGeSellItemMyNameActionGeSellPostRequest {
	r.gETransactionItemSchema = &gETransactionItemSchema
	return r
}

func (r ApiActionGeSellItemMyNameActionGeSellPostRequest) Execute() (*GETransactionResponseSchema, *http.Response, error) {
	return r.ApiService.ActionGeSellItemMyNameActionGeSellPostExecute(r)
}

/*
ActionGeSellItemMyNameActionGeSellPost Action Ge Sell Item

Sell an item at the Grand Exchange on the character's map.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiActionGeSellItemMyNameActionGeSellPostRequest
*/
func (a *MyCharactersAPIService) ActionGeSellItemMyNameActionGeSellPost(ctx context.Context, name string) ApiActionGeSellItemMyNameActionGeSellPostRequest {
	return ApiActionGeSellItemMyNameActionGeSellPostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return GETransactionResponseSchema
func (a *MyCharactersAPIService) ActionGeSellItemMyNameActionGeSellPostExecute(r ApiActionGeSellItemMyNameActionGeSellPostRequest) (*GETransactionResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GETransactionResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.ActionGeSellItemMyNameActionGeSellPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/action/ge/sell"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gETransactionItemSchema == nil {
		return localVarReturnValue, nil, reportError("gETransactionItemSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gETransactionItemSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionMoveMyNameActionMovePostRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
	destinationSchema *DestinationSchema
}

func (r ApiActionMoveMyNameActionMovePostRequest) DestinationSchema(destinationSchema DestinationSchema) ApiActionMoveMyNameActionMovePostRequest {
	r.destinationSchema = &destinationSchema
	return r
}

func (r ApiActionMoveMyNameActionMovePostRequest) Execute() (*CharacterMovementResponseSchema, *http.Response, error) {
	return r.ApiService.ActionMoveMyNameActionMovePostExecute(r)
}

/*
ActionMoveMyNameActionMovePost Action Move

Moves a character on the map using the map's X and Y position.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiActionMoveMyNameActionMovePostRequest
*/
func (a *MyCharactersAPIService) ActionMoveMyNameActionMovePost(ctx context.Context, name string) ApiActionMoveMyNameActionMovePostRequest {
	return ApiActionMoveMyNameActionMovePostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return CharacterMovementResponseSchema
func (a *MyCharactersAPIService) ActionMoveMyNameActionMovePostExecute(r ApiActionMoveMyNameActionMovePostRequest) (*CharacterMovementResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CharacterMovementResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.ActionMoveMyNameActionMovePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/action/move"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.destinationSchema == nil {
		return localVarReturnValue, nil, reportError("destinationSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.destinationSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionRecyclingMyNameActionRecyclingPostRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
	recyclingSchema *RecyclingSchema
}

func (r ApiActionRecyclingMyNameActionRecyclingPostRequest) RecyclingSchema(recyclingSchema RecyclingSchema) ApiActionRecyclingMyNameActionRecyclingPostRequest {
	r.recyclingSchema = &recyclingSchema
	return r
}

func (r ApiActionRecyclingMyNameActionRecyclingPostRequest) Execute() (*RecylingResponseSchema, *http.Response, error) {
	return r.ApiService.ActionRecyclingMyNameActionRecyclingPostExecute(r)
}

/*
ActionRecyclingMyNameActionRecyclingPost Action Recycling

Recyling an item. The character must be on a map with a workshop (only for equipments and weapons).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiActionRecyclingMyNameActionRecyclingPostRequest
*/
func (a *MyCharactersAPIService) ActionRecyclingMyNameActionRecyclingPost(ctx context.Context, name string) ApiActionRecyclingMyNameActionRecyclingPostRequest {
	return ApiActionRecyclingMyNameActionRecyclingPostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return RecylingResponseSchema
func (a *MyCharactersAPIService) ActionRecyclingMyNameActionRecyclingPostExecute(r ApiActionRecyclingMyNameActionRecyclingPostRequest) (*RecylingResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RecylingResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.ActionRecyclingMyNameActionRecyclingPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/action/recycling"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.recyclingSchema == nil {
		return localVarReturnValue, nil, reportError("recyclingSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.recyclingSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionTaskExchangeMyNameActionTaskExchangePostRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
}

func (r ApiActionTaskExchangeMyNameActionTaskExchangePostRequest) Execute() (*TaskRewardResponseSchema, *http.Response, error) {
	return r.ApiService.ActionTaskExchangeMyNameActionTaskExchangePostExecute(r)
}

/*
ActionTaskExchangeMyNameActionTaskExchangePost Action Task Exchange

Exchange 3 tasks coins for a random reward. Rewards are exclusive resources for crafting  items.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiActionTaskExchangeMyNameActionTaskExchangePostRequest
*/
func (a *MyCharactersAPIService) ActionTaskExchangeMyNameActionTaskExchangePost(ctx context.Context, name string) ApiActionTaskExchangeMyNameActionTaskExchangePostRequest {
	return ApiActionTaskExchangeMyNameActionTaskExchangePostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return TaskRewardResponseSchema
func (a *MyCharactersAPIService) ActionTaskExchangeMyNameActionTaskExchangePostExecute(r ApiActionTaskExchangeMyNameActionTaskExchangePostRequest) (*TaskRewardResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskRewardResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.ActionTaskExchangeMyNameActionTaskExchangePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/action/task/exchange"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionUnequipItemMyNameActionUnequipPostRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
	unequipSchema *UnequipSchema
}

func (r ApiActionUnequipItemMyNameActionUnequipPostRequest) UnequipSchema(unequipSchema UnequipSchema) ApiActionUnequipItemMyNameActionUnequipPostRequest {
	r.unequipSchema = &unequipSchema
	return r
}

func (r ApiActionUnequipItemMyNameActionUnequipPostRequest) Execute() (*EquipmentResponseSchema, *http.Response, error) {
	return r.ApiService.ActionUnequipItemMyNameActionUnequipPostExecute(r)
}

/*
ActionUnequipItemMyNameActionUnequipPost Action Unequip Item

Unequip an item on your character.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiActionUnequipItemMyNameActionUnequipPostRequest
*/
func (a *MyCharactersAPIService) ActionUnequipItemMyNameActionUnequipPost(ctx context.Context, name string) ApiActionUnequipItemMyNameActionUnequipPostRequest {
	return ApiActionUnequipItemMyNameActionUnequipPostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return EquipmentResponseSchema
func (a *MyCharactersAPIService) ActionUnequipItemMyNameActionUnequipPostExecute(r ApiActionUnequipItemMyNameActionUnequipPostRequest) (*EquipmentResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EquipmentResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.ActionUnequipItemMyNameActionUnequipPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/action/unequip/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unequipSchema == nil {
		return localVarReturnValue, nil, reportError("unequipSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unequipSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
	depositWithdrawGoldSchema *DepositWithdrawGoldSchema
}

func (r ApiActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRequest) DepositWithdrawGoldSchema(depositWithdrawGoldSchema DepositWithdrawGoldSchema) ApiActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRequest {
	r.depositWithdrawGoldSchema = &depositWithdrawGoldSchema
	return r
}

func (r ApiActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRequest) Execute() (*GoldResponseSchema, *http.Response, error) {
	return r.ApiService.ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostExecute(r)
}

/*
ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost Action Withdraw Bank Gold

Withdraw gold from your bank.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRequest
*/
func (a *MyCharactersAPIService) ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost(ctx context.Context, name string) ApiActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRequest {
	return ApiActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return GoldResponseSchema
func (a *MyCharactersAPIService) ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostExecute(r ApiActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRequest) (*GoldResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GoldResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/action/bank/withdraw/gold"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.depositWithdrawGoldSchema == nil {
		return localVarReturnValue, nil, reportError("depositWithdrawGoldSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.depositWithdrawGoldSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionWithdrawBankMyNameActionBankWithdrawPostRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
	simpleItemSchema *SimpleItemSchema
}

func (r ApiActionWithdrawBankMyNameActionBankWithdrawPostRequest) SimpleItemSchema(simpleItemSchema SimpleItemSchema) ApiActionWithdrawBankMyNameActionBankWithdrawPostRequest {
	r.simpleItemSchema = &simpleItemSchema
	return r
}

func (r ApiActionWithdrawBankMyNameActionBankWithdrawPostRequest) Execute() (*ActionItemBankReponseSchema, *http.Response, error) {
	return r.ApiService.ActionWithdrawBankMyNameActionBankWithdrawPostExecute(r)
}

/*
ActionWithdrawBankMyNameActionBankWithdrawPost Action Withdraw Bank

Take an item from your bank and put it in the character's inventory.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiActionWithdrawBankMyNameActionBankWithdrawPostRequest
*/
func (a *MyCharactersAPIService) ActionWithdrawBankMyNameActionBankWithdrawPost(ctx context.Context, name string) ApiActionWithdrawBankMyNameActionBankWithdrawPostRequest {
	return ApiActionWithdrawBankMyNameActionBankWithdrawPostRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ActionItemBankReponseSchema
func (a *MyCharactersAPIService) ActionWithdrawBankMyNameActionBankWithdrawPostExecute(r ApiActionWithdrawBankMyNameActionBankWithdrawPostRequest) (*ActionItemBankReponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionItemBankReponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.ActionWithdrawBankMyNameActionBankWithdrawPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/action/bank/withdraw"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.simpleItemSchema == nil {
		return localVarReturnValue, nil, reportError("simpleItemSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.simpleItemSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllCharactersLogsMyLogsGetRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	page *int32
	size *int32
}

// Page number
func (r ApiGetAllCharactersLogsMyLogsGetRequest) Page(page int32) ApiGetAllCharactersLogsMyLogsGetRequest {
	r.page = &page
	return r
}

// Page size
func (r ApiGetAllCharactersLogsMyLogsGetRequest) Size(size int32) ApiGetAllCharactersLogsMyLogsGetRequest {
	r.size = &size
	return r
}

func (r ApiGetAllCharactersLogsMyLogsGetRequest) Execute() (*DataPageActionSchema, *http.Response, error) {
	return r.ApiService.GetAllCharactersLogsMyLogsGetExecute(r)
}

/*
GetAllCharactersLogsMyLogsGet Get All Characters Logs

History of the last 300 actions of all your characters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllCharactersLogsMyLogsGetRequest
*/
func (a *MyCharactersAPIService) GetAllCharactersLogsMyLogsGet(ctx context.Context) ApiGetAllCharactersLogsMyLogsGetRequest {
	return ApiGetAllCharactersLogsMyLogsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataPageActionSchema
func (a *MyCharactersAPIService) GetAllCharactersLogsMyLogsGetExecute(r ApiGetAllCharactersLogsMyLogsGetRequest) (*DataPageActionSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataPageActionSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.GetAllCharactersLogsMyLogsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 50
		r.size = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCharacterLogsMyNameLogsGetRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	name string
	page *int32
	size *int32
}

// Page number
func (r ApiGetCharacterLogsMyNameLogsGetRequest) Page(page int32) ApiGetCharacterLogsMyNameLogsGetRequest {
	r.page = &page
	return r
}

// Page size
func (r ApiGetCharacterLogsMyNameLogsGetRequest) Size(size int32) ApiGetCharacterLogsMyNameLogsGetRequest {
	r.size = &size
	return r
}

func (r ApiGetCharacterLogsMyNameLogsGetRequest) Execute() (*DataPageActionSchema, *http.Response, error) {
	return r.ApiService.GetCharacterLogsMyNameLogsGetExecute(r)
}

/*
GetCharacterLogsMyNameLogsGet Get Character Logs

History of your character's last 300 actions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of your character.
 @return ApiGetCharacterLogsMyNameLogsGetRequest
*/
func (a *MyCharactersAPIService) GetCharacterLogsMyNameLogsGet(ctx context.Context, name string) ApiGetCharacterLogsMyNameLogsGetRequest {
	return ApiGetCharacterLogsMyNameLogsGetRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return DataPageActionSchema
func (a *MyCharactersAPIService) GetCharacterLogsMyNameLogsGetExecute(r ApiGetCharacterLogsMyNameLogsGetRequest) (*DataPageActionSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataPageActionSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.GetCharacterLogsMyNameLogsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/{name}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 50
		r.size = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyCharactersMyCharactersGetRequest struct {
	ctx context.Context
	ApiService MyCharactersAPI
	page *int32
	size *int32
}

// Page number
func (r ApiGetMyCharactersMyCharactersGetRequest) Page(page int32) ApiGetMyCharactersMyCharactersGetRequest {
	r.page = &page
	return r
}

// Page size
func (r ApiGetMyCharactersMyCharactersGetRequest) Size(size int32) ApiGetMyCharactersMyCharactersGetRequest {
	r.size = &size
	return r
}

func (r ApiGetMyCharactersMyCharactersGetRequest) Execute() (*DataPageMyCharacterSchema, *http.Response, error) {
	return r.ApiService.GetMyCharactersMyCharactersGetExecute(r)
}

/*
GetMyCharactersMyCharactersGet Get My Characters

List of your characters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMyCharactersMyCharactersGetRequest
*/
func (a *MyCharactersAPIService) GetMyCharactersMyCharactersGet(ctx context.Context) ApiGetMyCharactersMyCharactersGetRequest {
	return ApiGetMyCharactersMyCharactersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataPageMyCharacterSchema
func (a *MyCharactersAPIService) GetMyCharactersMyCharactersGetExecute(r ApiGetMyCharactersMyCharactersGetRequest) (*DataPageMyCharacterSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataPageMyCharacterSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MyCharactersAPIService.GetMyCharactersMyCharactersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/characters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 50
		r.size = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
